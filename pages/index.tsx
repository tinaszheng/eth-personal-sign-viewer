import { Wallet } from 'ethers'
import { hashMessage, recoverAddress, toUtf8Bytes, toUtf8String } from 'ethers/lib/utils'
import type { NextPage } from 'next'
import Head from 'next/head'
import { useEffect, useState } from 'react'

const DEFAULT_PRIVATE_KEY = '8da4ef21b864d2cc526dbdb2a120bd2874c36c9d0a1fb7f8c63d7f7a8b41de8f' // unsafe to use for realsies 
const wallet = new Wallet(DEFAULT_PRIVATE_KEY)

import styles from '../styles/Home.module.css'

const Home: NextPage = () => {
  const [message, setMessage] = useState<string | null>(null)
  const [signedMessage, setSignedMessage] = useState<string | null>(null)

  useEffect(() => {
    if (!message) return;

    wallet.signMessage(message).then((signed) => {
      setSignedMessage(signed)
    })
  }, [message])

  const signature = message ? wallet._signingKey().signDigest(hashMessage(message)) : null

  return (
    <div className={styles.container}>
      <Head>
        <title>Ethereum signing viewer</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <h1 className={styles.title}>
          Ethereum signing viewer
        </h1>
        <br/>
        Using private key: {DEFAULT_PRIVATE_KEY}<br/>
        Account: {wallet.address}<br/><br/>
        <div>
          <code>Begin by inputting a message:</code> <input value={message || ""} onChange={e => setMessage(e.target.value)}/>
        </div>
        <br/><br/>
        {message && 
        <div>
          <code>1. First we, create the utf8-byte encoding of the input message.</code><br/>
          {<div className="output">{toUtf8Bytes(message)}</div>}
          
          <code>2. Next, we utf8-byte encode the length of the message (length is {message.length}).</code><br/>
          {<div className="output">{toUtf8Bytes(String(message.length))}</div>}
          
          <code>3. Next, we create the keccak hash of the string &quot;\x19Ethereum Signed Message:\n{toUtf8Bytes(String(message?.length || 0))}{message ? toUtf8Bytes(message) : ""}&quot;</code><br/>
          {<div className="output">{hashMessage(message)}</div>}
          
          <code>4. We sign the hash from step 2 using the private key and get values (r, s, v).</code><br/>
          {signature && <div className="output">
            r: {signature.r} <br/>
            s: {signature.s} <br/>
            v: {signature.v} <br/>
            recoveryParam (v-27): {signature.recoveryParam}
            </div>}
          
          <code>Compressed signature:</code>
            {signedMessage && <div className="output">{signedMessage}</div>}
          
          <code>5. We send (r, s, v) and the original message to the client.</code><br/>
          {signature && <div className="output">sending (r, s, v) and {message}</div> }

          <code>6. Client calls ecrecover or ethers.recoverAddress with the message and signed message to get the signer&lsquo;s address.</code><br/>
          {signedMessage && message && <div className="output">{recoverAddress(hashMessage(message), signedMessage)}</div>}
        </div>}
      </main>

    </div>
  )
}

export default Home
