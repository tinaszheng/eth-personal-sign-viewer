import { ConnectKitButton, ConnectKitProvider, getDefaultClient } from 'connectkit'
import { Wallet } from 'ethers'
import { hashMessage, recoverAddress, toUtf8Bytes, toUtf8String } from 'ethers/lib/utils'
import type { NextPage } from 'next'
import Head from 'next/head'
import { useEffect, useState } from 'react'
import { createClient, useSignMessage, WagmiConfig } from 'wagmi'

const DEFAULT_PRIVATE_KEY = '8da4ef21b864d2cc526dbdb2a120bd2874c36c9d0a1fb7f8c63d7f7a8b41de8f' // unsafe to use for realsies
const wallet = new Wallet(DEFAULT_PRIVATE_KEY)

import styles from '../styles/Home.module.css'

const alchemyId = process.env.NEXT_PUBLIC_ALCHEMY_ID
if (!alchemyId) {
  throw new Error('Must specify an Alchemy ID')
}

const client = createClient(
  getDefaultClient({
    appName: 'ethereum-sign-viewer',
    alchemyId,
  })
)

type SignatureInfo = {
  message: string
  signature: string
}

const Home: NextPage = () => {
  const [message, setMessage] = useState<string | null>(null)
  const [signedMessage, setSignedMessage] = useState<string | null>(null)
  const [connectedWalletSignedMessage, setConnectedWalletSignedMessage] = useState<SignatureInfo | null>(null) 

  useEffect(() => {
    if (!message) return

    wallet.signMessage(message).then((signed) => {
      setSignedMessage(signed)
    })
  }, [message])

  const signature = message ? wallet._signingKey().signDigest(hashMessage(message)) : null

  return (
    <WagmiConfig client={client}>
      <ConnectKitProvider
        options={{
          walletConnectName: 'WalletConnect',
          embedGoogleFonts: true,
        }}
        theme="soft"
      >
        <div className={styles.container}>
          <Head>
            <title>Ethereum signing viewer</title>
            <meta name="description" content="Generated by create next app" />
            <link rel="icon" href="/favicon.ico" />
          </Head>

          <main className={styles.main}>
            <h1 className={styles.title}>Ethereum signing viewer</h1>
            <div>
              <code>Begin by inputting a message:</code>{' '}
              <input value={message || ''} onChange={(e) => setMessage(e.target.value)} />
            </div>
            <br />
            Try it on your own wallet! <br />
            <div style={{ display: 'flex', gap: '12px' }}>
              <ConnectKitButton /> {message && <SignMessageButton message={message} onSignature={setConnectedWalletSignedMessage} />}
            </div>
            {message && connectedWalletSignedMessage && <div>Your signature: {connectedWalletSignedMessage.signature} <br /> Your recovered address: <span style={{ color: 'green' }}>{recoverAddress(hashMessage(connectedWalletSignedMessage.message), connectedWalletSignedMessage.signature)}</span> </div>}

            <br />
            {message && (
              <div>
                <br />
                Example using private key: {DEFAULT_PRIVATE_KEY}
                <br />
                Account: {wallet.address}
                <br />
                <br />
                <code>1. First we, create the utf8-byte encoding of the input message.</code>
                <br />
                {<div className="output">{toUtf8Bytes(message)}</div>}

                <code>2. Next, we utf8-byte encode the length of the message (length is {message.length}).</code>
                <br />
                {<div className="output">{toUtf8Bytes(String(message.length))}</div>}

                <code>
                  3. Next, we create the keccak hash of the string &quot;\x19Ethereum Signed Message:\n
                  {toUtf8Bytes(String(message?.length || 0))}
                  {message ? toUtf8Bytes(message) : ''}&quot;
                </code>
                <br />
                {<div className="output">{hashMessage(message)}</div>}

                <code>
                  4. We sign the hash from step 3 with secp256k1 using the private key and get values (r, s, v).
                </code>
                <br />
                {signature && (
                  <div className="output">
                    r: {signature.r} <br />
                    s: {signature.s} <br />
                    v: {signature.v} <br />
                    recoveryParam (v-27): {signature.recoveryParam}
                  </div>
                )}

                <code>Compressed signature:</code>
                {signedMessage && <div className="output">{signedMessage}</div>}

                <code>5. We send (r, s, v) and the original message to the client.</code>
                <br />
                {signature && <div className="output">sending (r, s, v) and {message}</div>}

                <code>
                  6. Client calls ecrecover or ethers.recoverAddress with the message and signed message to get the
                  signer&lsquo;s address.
                </code>
                <br />
                {signedMessage && message && (
                  <div className="output">{recoverAddress(hashMessage(message), signedMessage)}</div>
                )}
              </div>
            )}
          </main>
        </div>
      </ConnectKitProvider>
    </WagmiConfig>
  )
}

function SignMessageButton({ message, onSignature }: { message: string, onSignature: (signature: SignatureInfo) => void }) {
  const { signMessageAsync } = useSignMessage()
  const sign = async () => {
    try {
      const signature = await signMessageAsync({ message })
      onSignature(({ message, signature }))
    } catch (e) {
      // do nothing
    }

  }

  return (
    <button className={styles.signMessageButton} onClick={sign}>
      Sign message
    </button>
  )
}

export default Home
